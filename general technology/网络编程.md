### TCP
流量控制、超时重传、拥塞控制



### UDP
1. 每个 UDP socket 都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区
2. 当套接口接收缓冲区满时，新来的数据报无法进入接收缓冲区，此数据报就被丢弃。UDP是没有流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的 UDP 丢弃数据报
3. 如果在传输过程中，一次传输被分成多个分片，传输中有一个小分片丢失，那接收端最终会舍弃整个文件，导致传输失败，这就是 UDP 不可靠的原因

#### UDP分片
数据链路层的最大传输单元是 1500 字节 (MTU) ，要想IP层不分包，那么 UDP 数据包的最大大小应该是1500字节 – IP头(20字节) – UDP头(8字节) = 1472字节， 但理论上 UDP 报文最大长度是 65507 字节

为了减少 UDP 包丢失的风险，我们最好能控制 UDP 包在 IP层协议的传输过程中不要被切割， 因为

`丢包原因`

1. UDP缓冲区满

如果 socket缓冲区满了，应用程序没来得及处理在缓冲区中的 UDP 包，那么后续来的 UDP 包会被内核丢弃，造成丢包。

在 socket 缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解UDP丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。

2. UDP缓冲区过小或文件过大

如果Client 发送的 UDP 报文很大，而 socket 缓冲区过小无法容下该 UDP 报文，那么该报文就会丢失

3. ARP 缓存过期

ARP 的缓存时间约 10 分钟，APR 缓存列表没有对方的 MAC 地址或缓存过期的时候，会发送 ARP 请求获取 MAC 地址，

在没有获取到 MAC 地址之前，用户发送出去的 UDP 数据包会被内核缓存到 arp_queue 这个队列中，默认最多缓存 3 个包，多余的 UDP 包会被丢弃

4. 接收端处理时间过长

调用 recv 方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用 recv 方法，在这二次调用间隔里，发过来的包可能丢失。

对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续 recv

5. 发送的包巨大

虽然 send 方法会帮你做大包切割成小包发送的事情，但包太大也不行。

例如超过 50K 的一个 udp 包，不切割直接通过send 方法发送也会导致这个包丢失。这种情况需要切割成小包再逐个 send

6. 发送的包频率太快

`丢包的解决方案`

1. 发送端延迟发送

2. 接收端的数据接收和数据处理相分离

用 recvfrom 函数收到数据之后尽快返回，进行下一次 recvfrom，可以通过 多线程+队列 来解决。
收到数据之后将数据放入队列中，另起一个线程去处理收到的数据

3. 接收端修改接收缓存大小

使用方法 2 依然出现大规模丢包的情况，需要进一步优化
解决方法:

使用 setsockopt 修改接收端的缓冲区大小
int rcv_size = 1024*1024; //1M
int optlen=sizeof(rcv_size);
//设置好缓冲区大小
int err=setsockopt(sock,SOL_SOCKET,SO_RCVBUF,(char *)&rcv_size,optlen);
设置完毕可以通过下列函数，来查看当前 sock 的缓冲区大小

setsockopt(sock,SOL_SOCKET,SO_RCVBUF,(char *)&rcv_size,(socklen_t *)&optlen);
但是,会发现查到的大小并不是1M而是256kb,后来发现原来是 linux 系统默认缓冲区大小为 128kb，设置最大是这个的 2倍，所以需要通过修改系统默认缓冲区大小来解决

使用root账户在命令行下输入:

vi /etc/sysctl.conf
添加一行记录(1049576=1024*1024=1M)

net.core.rmem_max=1048576
保存之后输入

/sbin/sysctl -p
使修改的配置生效

此时可以通过 sysctl -a|grep rmem_max 来看配置是否生效.

生效之后可以再次运行程序来 getsockopt 看缓冲区是否变大了,是否还会出现丢包现象了

楼主使用的是 方法2+方法3 双管齐下，已经不会出现丢包现象了，如果还有不同程度的丢包 可以通过方法三种继续增加缓冲区大小的方式来解决。



