### 消息队列

优点：

1. 解耦
2. 异步:

典型场景就是将比较耗时而且不需要即时（同步）返回结果的操作，通过消息队列来实现异步化

3. 削峰


缺点：-----如何克服？

1. 系统可用性降低
2. 系统复杂性增加


### 消息队列模型
#### 点对点模型
三个角色：
1. 消息队列
2. 发送者
3. 接收者

每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，可以放在 内存 中也可以 持久化，直到他们被消费或超时

特点：
1. 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)
2. 发送者和接收者之间在时间上没有依赖性
3. 接收者在成功接收消息之后需向队列应答成功

#### 发布订阅消息模型Topic
三个角色：
1. 主题(Topic)
2. 发布者(Publisher)
3. 订阅者(Subscriber)

多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。

特点：
1. 每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费
2. 发布者和订阅者之间有时间上的依赖性
3. 针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息
4. 为了消费消息，订阅者必须保持运行的状态

## nsqd

1. Topic: 一个 topic 就是程序发布消息的一个逻辑键，当程序第一次发布消息时就会创建 topic
2. Channels: hannel 与消费者相关，是消费者之间的负载均衡， channel 在某种意义上来说是一个“队列”。每当一个发布者发送一条消息到一个 topic，消息会被复制到所有消费者连接的 channel 上，消费者通过这个特殊的 channel 读取消息，实际上，在消费者第一次订阅时就会创建 channel。 Channel 会将消息进行排列，如果没有消费者读取消息，消息首先会在内存中排队，当量太大时就会被保存到磁盘中
3. Messages：消息构成了我们数据流的中坚力量，消费者可以选择结束消息，表明它们正在被正常处理，或者重新将他们排队待到后面再进行处理。每个消息包含传递尝试的次数，当消息传递超过一定的阀值次数时，我们应该放弃这些消息，或者作为额外消息进行处理。
