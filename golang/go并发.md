### goroutine原理

不用共享内存的方式传递数据，而是通过channel，channel主要用来在多个goroutine之间传递数据，并且还会保证流程的安全性


### channel

channel是在多个goroutine之间传递数据和同步的重要手段，而对通过的操作本身也是同步的。在同一时刻，仅有一个goroutine能向一个通过发送元素值，同时也只有一个goroutine能从它那里接收元素值。在通道中，各个元素值都是严格按照发送到此的先后顺序排列的，最早被发送最先被接收。

试图从一个未被初始化的channel接收元素值，会造成当前goroutine的永久阻塞

#### 非缓冲的channel

1. 向此类channel发送元素的操作会被阻塞，直到至少有一个针对该通道的接收操作运行为止。该接收操作会先得到元素值的副本，然后再唤醒发送方所在的goroutine之后返回，即接收操作会在对方的发送操作完成之前完成

2. 此类channel接收元素值的操作会被阻塞，直到至少有一个针对该通道的发送操作进行为止。该发送操作会直接把元素值复制给接收方，然后在唤醒接收方所在的goroutine之后返回，即发送操作会在对应的接收操作完成之前完成


### select
如果select语句中的所有case都不满足选择条件，并且没有default，那么当前goroutine就会一直阻塞于此。


### 互斥锁




#### 读写锁

1. 同时只能有一个goroutine能够获得写锁定
2. 同时可以有任意多个goroutine获得读锁定
3. 同时只能存在写锁定或读锁定


在读写锁管辖的范围内，它允许任意个读操作的同时进行。但是在同一时刻，它只允许有一个写操作在进行

并且在某一个写操作被进行的过程中，读操作的进行也是不被允许的。也就是说读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。但是，多个读操作之间却不存在互斥关系。



