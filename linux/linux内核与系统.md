
当硬件和系统通信的时候，首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。中断通常对应着一个中断号，内核通过这个中断号查找相应的终端服务程序，并调用这个程序响应和处理中断。

1. linux支持动态加载内核模块。尽管linux内核也是单内核，可是允许在需要的时候动态地卸除和加载部分内核代码
2. linux支持对称多处理（SMP）机制，尽管许多Unix的变体也支持SMP，但传统的Unix并不支持这种机制
3. linux内核可以抢占，其允许在内核运行的任务优先执行的能力。
4. linux对线程的支持，内核并不区分线程和其他的一般进程。对于内核来说，所有的进程都一样--只不过是其中的一些共享资源而已
5. linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统


inline函数会在它所调用的位置上展开，这样做可以消除函数调用和返回所带来的开销（寄存器存储和恢复）；inline函数必须在使用之前就定义好，否则编译器就没法把这个函数展开


### 内存保护机制
如果一个用户程序试图进行一次非法的内存访问，内核就会发现错误，发送SIGSEGV信号，并结束整个进程。如果内核发生错误会导致oops，在内核中，不应该去做访问非法的内存地址以及引用空指针的事情。

内核栈的大小是两页，即32位机的内核栈是8KB，而64位机是16KB，这是固定不变的，每个处理器都有自己的栈

内核解决竞争的办法是自旋锁和信号量

### 进程和线程

线程是进程中活动的对象，每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，对于linux，线程只不过是一种特殊的进程。

进程提供两种虚拟机制：虚拟处理器和虚拟内存

内核把进程的列表存放在叫做任务队列（task list）的双向循环列表中


调度策略通常在两个矛盾的目标中间寻找平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）

