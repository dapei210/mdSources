C++11
##

修饰符 volatile 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程

用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率

建议使用 for(;;) 结构来表示一个无限循环

Lambda

#### 引用和指针
1. 不存在空引用。引用必须连接到一块合法的内存。
2. 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
3. 引用必须在创建时被初始化。指针可以在任何时间被初始化。

### vector
vector 是基于数组的数据结构，但它可以自动管理内存

### 类

一个派生类继承了所有的基类方法，但下列情况除外：

1. 基类的构造函数、析构函数和拷贝构造函数。
2. 基类的重载运算符。
3. 基类的友元函数。

当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型，几乎不使用 protected 或 private 继承，通常使用 public 继承

1. 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
2. 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
3. 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

#### 函数重载与运算符重载
在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数

#### 多态
C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数

#### 虚函数与纯虚函数
虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定

想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数



面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。

外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。

这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此

### 模板



## string

在传递参数的时候，如果参数是string类型，可以用string类型的引用，减少内存的拷贝。


### 枚举类

限定作用域的枚举类

特点
1. 避免发生隐式转换

不允许发生任何隐式转换。如果非要转换，按就只能使用static_cast进行强制转换
2. 降低命名空间污染

在其他地方使用枚举中的变量就要声明命名空间

3. 可以前置声明

```
enum Color;			//错误
enum class Color;	//正确
```


### 类和数据

#### static类成员
每个static数据成员是与类关联的对象，并不与该类的对象关联

其优点如下：
1. static成员的名字在类的作用域中，可以避免与其他类的成员或全局对象名字冲突
2. 可以实施封装，static成员可以是私有成员，而全局对象不可以
3. 阅读程序清晰地显示static成员与特定类关联


类成员函数可以不用作用域操作符来引用类的static成员

static函数没有this指针，因为其是类的组成部分而不是对象的组成部分

static成员不是通过类构造函数进行初始化，而是应该在定义时进行初始化

像使用任意的类成员一样，在类定义体外部引用类的static成员时，必须指定成员是在哪个类中定义的，然而，static关键字只能用于
类定义体内部的声明中，定义不能标识为static

static成员数据成员通常在定义时初始化

const static数据成员在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义



